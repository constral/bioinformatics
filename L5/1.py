import random

SEQ = """CCCAGGGTCCGATGGGAAAGTGTAGCCTGCAGGCCCACACCTCCCCCTGTGAATCACGCCTGGCGGGACAAGAAAGCCCAAAACACTCCAAACAATGAGTTTCCAGTAAAATATGACAGACATGATGAGGCGGATGAGAGGAGGGACCTGCCTGGGAGTTGGCGCTAGCCTGTGGGTGATGAAAGCCAAGGGGAATGGAAAGTGCCAGACCCGCCCCCTACCCATGAGTATAAAGCACTCGCATCCCTTTGCAATTTACCCGAGCACCTTCTCTTCACTCAGCCTTCTGCTCGCTCGCTCACCTCCCTCCTCTGCACCATGACTACCTGCAGCCGCCAGTTCACCTCCTCCAGCTCCATGAAGGGCTCCTGCGGCATCGGGGGCGGCATCGGGGCGGGCTCCAGCCGCATCTCCTCCGTCCTGGCCGGAGGGTCCTGCCGCGCCCCCAACACCTACGGGGGCGGCCTGTCTGTCTCATCCTCCCGCTTCTCCTCTGGGGGAGCCTATGGGTTGGGGGGCGGCTATGGCGGTGGCTTCAGCAGCAGCAGCAGCAGCTTTGGTAGTGGCTTTGGGGGAGGATATGGTGGTGGCCTTGGTGCTGGCTTGGGTGGTGGCTTTGGTGGTGGCTTTGCTGGTGGTGATGGGCTTCTGGTGGGCAGTGAGAAGGTGACCATGCAGAACCTCAATGACCGCCTGGCCTCCTACCTGGACAAGGTGCGTGCTCTGGAGGAGGCCAACGCCGACCTGGAAGTGAAGATCCGTGACTGGTACCAGAGGCAGCGGCCTGCTGAGATCAAAGACTACAGTCCCTACTTCAAGACCATTGAGGACCTGAGGAACAAGGTGGGTGAATGGGCAGCAGAAGGCACCATTCCAGCTAGCTCCTTCTGGGAACAATTCATGCCCCAGGCCGCTGAGACCTTAAGATTTCTCTATAGGACAGAGTCCACCCCAGATCCCTTCTTTCGAGGTCTTGGATGCCCTAAGACTGATCAGTGAGAAGATGCTTTCCCTTCCCCAGGCCTCCTCATCCCCTTCTGATCTCAAATCCTCAGACCATGTGAGATCAGTGATTCCTATCCTTACATTTTTTAGAGGAAGCAGTTGAAGCTTCGAGAGGTGCTGTGACCAGCTGCAGGTCACATAGCAAATTAATGGCAGAGCAAGGCTGGGGCCCTTGTGCCTACCTTCCAGCACAGGAGGCAGCTACTTGTTCTCCAGCACAGGGGAGGAGTGAGGCTCTAACGGGACCAGGCAAGACATCCAAACCACTCATTAGCTCACTAGTCTGGGCTGTGGTTGCCGCCGCCCATAAGCCTTGGTACAGGCTGGTCCCTCCCCACAGCCAGGCGGGCATGGAGAGCCTGCAGAGACAATTAGTGTGGTCCCTTGATGTGCCCTGCACAGAGAGAGCCTGGCAGGCTTGTGCCCTGACTCTAGCCCCCTCCTCCCTGCTCCCACATTACTTGGGAGCCCTCCCTGCTGGAGTCTGTTGGGCTCTAATGACTTGCATGGATTAGGGAAATTCAAGTGATGAGGTGGGGAAATCCAACCAGACTCAGGGGCCAATATATCTTCTTATTCTTCCCCTGAGTCCTCTTTTCTAATCCCCTGTGTTAGTTGGGTTTTATCTCTTCACAAAGTTCCACTTGAAGTCCCATGGCCTGTGAGCTTGAAAAGGAATGTGCATATCTGCAGAGGACTGGCAGGGCTGGCCTGATGCAGACAGAAGAGAGGTCAGCTCAGGAAGGAGGGCTAGGGAGCCTCAGATTATTCTCCTCACCTGGAGGTGGGGAACTTGAAGCCCCAAGACCCATTAGGTTTTGCCCAGCAAGACACTGGCAGAATTGGGACCAGAACTCCTGGGCTTTCGATTCTAAGCCCGGGGCTGCCATCTACCCCCTCTGTTGACCATGAGTTAGCAAAGTCTTAGGACAGGCCTGGGGCATCTGTTTTCCTTTGGGCTGCTATGGTCAAGTTTTGTGGGGGAAAAGGGGGATTCAGGCAAGAACATGAAGCAAGAGCTTAATGTAGGCTACAGTGAAGTCCAGCTTGTGAAGTCCATTTGACAAATTACCTGTGCCTTTTCCATCCTGCAGATTCTCACAGCCACAGTGGACAATGCCAATGTCCTTCTGCAGATTGACAATGCCCGTCTGGCCGCGGATGACTTCCGCACCAAGTGAGTTTGAAATGGTGGGCCAGAACATCCAGTGTCCCCAGAGTAGGGCATTTTTGGAGCAGTGTTTCCCAAATAGAACTAGCCAGTACCAGGATAGGTGCATGAAAACTCCCTGGGGTGCTTATAAAAGAATAAGACTCTTGGGCCCCACCCTTGGAGTTTTGATTCAGCTATTTATAGCAGGTTACCTGGGTGATTCTGGTCCACAGCCAGGTTTCAGAACCGCTGCTTTAGGGAGAGGCACTTTCCACTTCCCCAGCTGCCCTTGAAGTATAGGAAGGAATCATAGTTGGAGGACTTCTGCATTATTTGTTGGCTGAAGCTAGAAGTGCAACCCCCTCCTGATTTCTGCAGCAAGATGAACTGCCTTATCCCCAGCCCGCAGGAATGTTCATATCTGAGCAATCAATGGGCACTGTGTTCAACCACGCCATTTTTCAAGATTGGCTCCTTAAACCACCCACAAGGCACCAGCTCTGGGAGAAGCTGCAGGGAGAAGAGAACAAAGCCCTCGCTGTGATCAGGATGGGTGTCTCATACCTTTTCTCTGGGGTCATTCCAGGTATGAGACAGAGTTGAACCTGCGCATGAGTGTGGAAGCCGACATCAATGGCCTGCGCAGGGTGCTGGACGAACTGACCCTGGCCAGAGCTGACCTGGAGATGCAGATTGAGAGCCTGAAGGAGGAGCTGGCCTACCTGAAGAAGAACCACGAGGAGGTGAGAACTATATGGAAAAGTCAGCTTAAAAGAAATGCAGGGAGGCTGGGTACAGTGGTGCGTGCCCATAGTCCCAGCTACTTGGGAGGCTGAGACAGGAGGATCACTTGAACACAGGAGTTTGAGTCCAGCCTGGGCAACAAGGTTAGACCCTGTCCAAAAAAAAAAAAAAAAAAAAAAAAAAAGAGAGAGAGAGAGAGAGAGATTGAGAGAGAGAGAGAGAAGGGAGAGTCGAGATAGAATTGTGATGGTGGGAGGGCAGTATTCAGGCCTAAGGAACACCAATCCGCTGCCATGGTGGAACTCCTGACTGTGGACTGTCCCTGGCTTGCAGGAGATGAATGCCCTGAGAGGCCAGGTGGGTGGAGATGTCAATGTGGAGATGGACGCTGCACCTGGCGTGGACCTGAGCCGCATTCTGAACGAGATGCGTGACCAGTATGAGAAGATGGCAGAGAAGAACCGCAAGGATGCCGAGGAATGGTTCTTCACCAAGGTGGGTGTCATTTGAGGTGGAAGGAACCCAGACCACCTGCCTTCTGGGGCCTTCTGGTGTGAATGGCATTCTCTTTTTTGCAGACAGAGGAGCTGAACCGCGAGGTGGCCACCAACAGCGAGCTGGTGCAGAGCGGCAAGAGCGAGATCTCGGAGCTCCGGCGCACCATGCAGAACCTGGAGATTGAGCTGCAGTCCCAGCTCAGCATGGTAGGAATAGTGCCAGGAAGGGTGGTGCACCCAGGACTGGCAGGGAGAGAACGGCCACACTCACTAATCGTTGATTCCCTTCCCTCCCTCACAGAAAGCATCCCTGGAGAACAGCCTGGAGGAGACCAAAGGTCGCTACTGCATGCAGCTGGCCCAGATCCAGGAGATGATTGGCAGCGTGGAGGAGCAGCTGGCCCAGCTCCGCTGCGAGATGGAGCAGCAGAACCAGGAGTACAAGATCCTGCTGGACGTGAAGACGCGGCTGGAGCAGGAGATCGCCACCTACCGCCGCCTGCTGGAGGGCGAGGACGCCCAGTGAGTCTTGGCCCTCCCCTTAGTCCGCCCCCCCCATGGCACTCTCACGGCCCCACCATGTATCTAATGATCCTGTCCTTTTCTATTTTCACAGCCTCTCCTCCTCCCAGTTCTCCTCTGGATCGCAGTCATCCAGAGATGGTAAGACCCTCCTCCTCTGCAGGCCTGGGCTCCAGGCCACCCTCTGTACCCCAAGCAGGTCTAGGCATTGGCTAGGGGCTCCGTGAGGGGCTGAGCTCTAGTGCTGTCACCCAGTTTCCCTTGTGAACCTCCTTGGGTGGAAGAAGCTATTTTCTAAACCCTCCTTAGGGCTAGGAGAGGCAGCCCCCACCTCTTGCCTTCTACGTGGTGTCTGTGGCAGATCCTATTAGCTGTTGTGGTCAGCACCATGAACAAGGGCCCTACAGCGGTCTTCCCACTGAGACCACTCCATTGGGTGAATATGGATGGAACCAGCCAGGTGTGAGCTCTTAGGAAGCTCTAATCTGAGGGCAAAGACTCTGTCTCTGACCTTTGGGAGCCCTCGTCTGAAAGAAATGTGTTGATGGTATCAGTGCTTGGGCAACAGCAGGGAGTGAAGCAGTAATCAGGGGAGAGGGCAATGGGGAGCCAGTTTGAGTTTCCTCACCTTCTTGGCCTCCTTACTCCTGATTAGTCCATTGTCTGTCCACCTCTGGTAACGTCCTCTTCCCACCTCTTCCCCAGTGACCTCCTCCAGCCGCCAAATCCGCACCAAGGTCATGGATGTGCACGATGGCAAGGTGGTGTCCACCCACGAGCAGGTCCTTCGCACCAAGAACTGAGGCTGCCCAGCCCCGCTCAGGCCTAGGAGGCCCCCCGTGTGGACACAGATCCCACTGGAAGATCCCCTCTCCTGCCCAAGCACTTCACAGCTGGACCCTGCTTCACCCTCACCCCCTCCTGGCAATCAATACAGCTTCATTATCTGAGTTGCATAATTCTCGCCTCTCTCTGGTCATTGTTAGGAGTGGGGGTGGGGAGAAAGTGGGAGAGCATCTCTTTGGAGCTTGTCATGCACCTGGCTATGGCCCCTGGGACTGGGAGAAAAGTCCTGGGGGTGGGTTGGGCTCAGGTCCCAGGATATCTTTCGCCATCTCAGAAGACACAGATAGATGTGTGTACCAGGTCATATGTGGTGTCTCCTAGGGTACGGAGGGATATTCATTCATTTACTCACTCATTTTCATGTGTGTCCATTCATTCACCAGATATTGAGTGCCTCTATGTCAGGCACTATGTTAGGTTAAGGATTCCTGATGTTTTTGTGTATCAGGGATTCCTTGGAGAATATTGAAAGCTATAGATCTTTCCTTCTGCCCCCTACCTTCAAATAAGCATACATACATTTGCATACATGTCATGGGGTTCATGGGTCTCCTAGAGCTCCTTACCGGAGT"""

# how many random fragments to take
n_reads = 2000
# shortest fragment size
min_len = 100
# longest fragment size
max_len = 150
# minimum exact overlap length to join fragments      
min_ov = 10



# sample n_reads random substrings from seq
def sample_reads(seq):
    # pick a random start and a random length for each fragment
    # fragments may overlap each other and some positions may be sampled many times
    L = len(seq)
    reads = []
    for _ in range(n_reads):
        l = random.randint(min_len, max_len)
        # if fragment length >= whole sequence, take the whole sequence
        s = 0 if l >= L else random.randint(0, L - l)
        reads.append(seq[s:s + l])
    return reads

# find the longest exact match where the end of a matches the start of b
# return 0 if no match of at least min_ov is found
def best_overlap(a, b):
    # try the biggest possible overlap first, then smaller ones
    # this returns the length of that overlap (an integer)
    m = min(len(a), len(b))
    for l in range(m, min_ov - 1, -1):
        if a[-l:] == b[:l]:
            return l
    return 0

# finding the single best overlap
def greedy_assemble(reads):
    # contigs will hold assembled sequences
    contigs = []
    while reads:
        # take one read as the current contig to extend
        contig = reads.pop()
        extended = True
        while extended:
            extended = False
            best_index = -1
            best_len = 0
            best_dir = 0  # 1 means contig -> read, -1 means read -> contig
            # check every remaining read for the best overlap with current contig
            for i, r in enumerate(reads):
                ol = best_overlap(contig, r)
                if ol > best_len:
                    best_len, best_index, best_dir = ol, i, 1
                ol = best_overlap(r, contig)
                if ol > best_len:
                    best_len, best_index, best_dir = ol, i, -1
            # if we found an overlap at least min_ov, attach that read
            if best_len >= min_ov:
                r = reads.pop(best_index)
                if best_dir == 1:
                    # attach r to the right of contig, trimming the overlapping part
                    contig = contig + r[best_len:]
                else:
                    # attach r to the left of contig, trimming overlap
                    contig = r + contig[best_len:]
                extended = True
        contigs.append(contig)
    return contigs

reads = sample_reads(SEQ)
contigs = greedy_assemble(reads)
contigs.sort(key=len, reverse=True)

# print: original length, number of contigs, length of largest contig
print(len(SEQ), len(contigs), len(contigs[0]))
